const express = require('express');
const router = express.Router();
const User = require('../models/User');
const Device = require('../models/Device');
const logger = require('../utils/logger');
const LogModel = require('../models/Log');
const otp = require('../lib/otp');
const jwt = require('jsonwebtoken');
const emailService = require('../lib/emailService');

// Normalize phone input to E.164 without plus for KE (e.g. 2547XXXXXXXX)
function normalizePhoneInput(phone) {
    if (!phone) return '';
    const digits = String(phone).replace(/\D/g, '');
    if (digits.startsWith('0')) return '254' + digits.slice(1);
    if (digits.startsWith('254')) return digits;
    if (digits.startsWith('7')) return '254' + digits;
    if (digits.startsWith('1')) return '254' + digits;
    return digits;
}

// Register: create user entry and send OTP for phone verification
router.post('/register', async (req, res) => {
    try {
        const { name, phone, email, password, mac, referralCode } = req.body;

        // Validate required fields
        if (!phone || !password) {
            return res.status(400).json({ error: 'phone and password required' });
        }

        // Validate password length
        if (password.length < 6) {
            return res.status(400).json({ error: 'Password must be at least 6 characters' });
        }

        const normalizedPhone = normalizePhoneInput(phone);

        // Check if phone already exists
        let user = await User.findOne({ phone: normalizedPhone });
        if (user) {
            return res.status(400).json({ error: 'Phone number already registered' });
        }

        // Normalize email
        let normalizedEmail = undefined;
        if (email && typeof email === 'string') {
            const trimmedEmail = email.trim();
            if (trimmedEmail.length > 0) {
                normalizedEmail = trimmedEmail.toLowerCase();
            }
        }

        // Check if email already exists
        if (normalizedEmail) {
            const existingEmailUser = await User.findOne({ email: normalizedEmail });
            if (existingEmailUser) {
                return res.status(400).json({ error: 'Email already registered' });
            }
        }

        // Handle Referral Logic
        let referrer = null;
        let referralPoints = 0;
        let bonusPoints = 0;

        if (referralCode) {
            try {
                // Find referrer
                referrer = await User.findOne({ referralCode });
                if (referrer) {
                    // Define points for 2 hours (assuming 1 point ~ 1 KES or arbitrary unit)
                    // If no specific conversation rate exists, we'll establish:
                    // 2 hours free connection.
                    // Let's check if there's a reference to points value. 
                    // For now, I will use a reasonable default: 50 points per hour? 
                    // Let's stick to the existing points.js logic:
                    // const referralPoints = 50; 
                    // const bonusPoints = 25;
                    // But requirement says "2 hours of free connection".
                    // I will define this as 100 points for Referrer and 50 for New User (approx value).
                    // Or better, I will check if I can give "Time" directly? No, schema supports points.
                    // So I will give points.
                    referralPoints = 50; // Basic reward
                    bonusPoints = 25; // Basic reward for new user
                } else {
                    logger.warn(`Invalid referral code used during registration: ${referralCode}`);
                }
            } catch (refErr) {
                logger.error('Error processing referral code', { error: refErr.message });
            }
        }

        // Create new user
        user = new User({
            name: name?.trim() || undefined,
            phone: normalizedPhone,
            email: normalizedEmail,
            // Generate a referral code for the new user immediately
            referralCode: undefined, // Will be generated by pre-save or we do it explicitly?
            // The schema has a helper but not a pre-save hook for it shown in view_file.
            // I should generate it explicitly to be safe.
        });

        // Generate referral code for new user
        let newReferralCode;
        let isUnique = false;
        // Simple loop to ensure uniqueness (rare collision)
        let attempts = 0;
        while (!isUnique && attempts < 5) {
            newReferralCode = user.generateReferralCode();
            const existing = await User.findOne({ referralCode: newReferralCode });
            if (!existing) isUnique = true;
            attempts++;
        }
        if (isUnique) user.referralCode = newReferralCode;

        if (referrer) {
            user.referredBy = referrer._id;
            user.points = bonusPoints; // Award bonus points immediately
        }

        await user.setPassword(password);
        await user.save();

        // Award points to referrer
        if (referrer) {
            // We use the addPoints helper which saves the referrer
            await referrer.addPoints(referralPoints, 'referral');

            // Log points transaction for referrer
            const Points = require('../models/Points');
            await Points.create({
                userId: referrer._id,
                amount: referralPoints,
                type: 'referral',
                description: `Earned ${referralPoints} points for referring ${user.phone}`,
                relatedUser: user._id
            });

            // Log points transaction for new user
            if (bonusPoints > 0) {
                await Points.create({
                    userId: user._id,
                    amount: bonusPoints,
                    type: 'bonus',
                    description: `Welcome bonus for using referral code`,
                    relatedUser: referrer._id
                });
            }

            await LogModel.create({
                level: 'info',
                source: 'auth',
                message: 'referral-successful-signup',
                metadata: {
                    referrerId: referrer._id,
                    newUserId: user._id,
                    referralCode
                }
            });
        }

        // Add user to Brevo contact list
        if (user.email && user.emailMarketingOptIn) {
            const brevoListId = process.env.BREVO_LIST_ID ? parseInt(process.env.BREVO_LIST_ID) : null;
            emailService.addContactToBrevo(
                user.email,
                {
                    FIRSTNAME: user.name || '',
                    PHONE: user.phone || '',
                    SMS: user.phone || '',
                },
                brevoListId ? [brevoListId] : [],
                false
            ).then(result => {
                if (result.success && result.id) {
                    user.brevoContactId = result.id;
                    user.save().catch(err => logger.error('Failed to save Brevo contact ID', { error: err.message }));
                }
            }).catch(err => {
                logger.error('Failed to add user to Brevo', { error: err.message, userId: user._id });
            });
        }

        // Send email verification email
        if (user.email) {
            try {
                const emailTemplates = require('../lib/emailTemplates');
                const config = emailService.getEmailConfig();

                const verificationToken = user.generateEmailVerificationToken();
                await user.save();

                const verificationLink = `${config.frontendUrl}/auth/verify-email?token=${verificationToken}`;

                emailService.sendEmailAsync({
                    to: user.email,
                    toName: user.name || user.email,
                    subject: 'Verify Your Email Address - Wifi Mtaani',
                    htmlContent: emailTemplates.getEmailVerificationTemplate(user.name || 'User', verificationLink, 24),
                });
            } catch (emailError) {
                logger.error('Error preparing email verification email', { error: emailError.message, userId: user._id });
            }
        }

        // Link Device
        if (mac) {
            try {
                const Device = require('../models/Device');
                const device = await Device.findOne({ mac });
                if (device && !device.userId) {
                    device.userId = user._id;
                    await device.save();
                    await LogModel.create({
                        level: 'info',
                        source: 'auth',
                        message: 'device-linked-during-registration',
                        metadata: { phone: normalizedPhone, userId: user._id, mac, deviceId: device._id }
                    });
                }
            } catch (deviceError) {
                logger.error('Failed to link device during registration', { error: deviceError.message, mac, userId: user._id });
            }
        }

        await LogModel.create({
            level: 'info',
            source: 'auth',
            message: 'user-registered',
            metadata: { phone: normalizedPhone, userId: user._id, email: user.email || null }
        });

        const code = await otp.createAndSend(normalizedPhone);

        const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET, { expiresIn: process.env.JWT_EXPIRY || '7d' });

        res.json({
            ok: true,
            message: 'registered successfully',
            token,
            user: {
                _id: user._id,
                phone: user.phone,
                name: user.name,
                email: user.email,
                emailVerified: user.emailVerified || false,
                phoneVerified: user.phoneVerified || false,
                freeTrialUsed: user.freeTrialUsed,
                createdAt: user.createdAt,
                referralCode: user.referralCode,
                points: user.points
            },
            codeSent: !!code
        });
    } catch (error) {
        logger.error('Registration error', {
            error: error.message,
            stack: error.stack,
            phone: req.body?.phone,
            email: req.body?.email
        });

        if (error.code === 11000) {
            const field = Object.keys(error.keyPattern || {})[0] || 'field';
            return res.status(400).json({
                error: `${field === 'phone' ? 'Phone' : 'Email'} already registered`
            });
        }

        if (error.name === 'ValidationError') {
            const messages = Object.values(error.errors || {}).map(e => e.message);
            return res.status(400).json({
                error: messages.length > 0 ? messages[0] : 'Validation error'
            });
        }

        res.status(500).json({
            error: 'Registration failed. Please try again later.'
        });
    }
});

// Verify OTP
router.post('/verify-otp', async (req, res) => {
    const { phone, code } = req.body;
    if (!phone || !code) return res.status(400).json({ error: 'phone and code required' });
    const normalizedPhone = normalizePhoneInput(phone);
    const ok = otp.verify(normalizedPhone, code);
    if (!ok) {
        await LogModel.create({ level: 'warn', source: 'auth', message: 'otp-failed', metadata: { phone: normalizedPhone } });
        return res.status(400).json({ error: 'invalid or expired otp' });
    }
    const user = await User.findOneAndUpdate({ phone: normalizedPhone }, { phoneVerified: true }, { new: true });
    await LogModel.create({ level: 'info', source: 'auth', message: 'otp-verified', metadata: { phone: normalizedPhone, userId: user._id } });

    // issue JWT
    const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET, { expiresIn: process.env.JWT_EXPIRY || '7d' });
    res.json({ ok: true, token, user: { id: user._id, phone: user.phone, name: user.name } });
});

// Login
router.post('/login', async (req, res) => {
    const { phone, password } = req.body;
    const normalizedPhone = normalizePhoneInput(phone);
    const user = await User.findOne({ phone: normalizedPhone });
    if (!user) return res.status(404).json({ error: 'User not found' });
    const ok = await user.comparePassword(password);
    if (!ok) return res.status(401).json({ error: 'Wrong password' });
    const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET, { expiresIn: process.env.JWT_EXPIRY || '7d' });
    res.json({
        ok: true,
        token,
        user: {
            _id: user._id,
            phone: user.phone,
            name: user.name,
            email: user.email,
            emailVerified: user.emailVerified || false,
            phoneVerified: user.phoneVerified || false,
            freeTrialUsed: user.freeTrialUsed,
            createdAt: user.createdAt
        }
    });
});

// Get current user (protected route)
router.get('/me', async (req, res) => {
    try {
        const token = req.headers.authorization?.replace('Bearer ', '');
        if (!token) return res.status(401).json({ error: 'No token provided' });

        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        const user = await User.findById(decoded.userId).select('-passwordHash');
        if (!user) return res.status(404).json({ error: 'User not found' });

        res.json({
            ok: true,
            user: {
                _id: user._id,
                phone: user.phone,
                name: user.name,
                email: user.email,
                emailVerified: user.emailVerified || false,
                phoneVerified: user.phoneVerified || false,
                freeTrialUsed: user.freeTrialUsed,
                createdAt: user.createdAt
            }
        });
    } catch (error) {
        res.status(401).json({ error: 'Invalid token' });
    }
});

// Update profile
router.put('/profile', async (req, res) => {
    try {
        const token = req.headers.authorization?.replace('Bearer ', '');
        if (!token) return res.status(401).json({ error: 'No token provided' });

        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        const user = await User.findById(decoded.userId);
        if (!user) return res.status(404).json({ error: 'User not found' });

        const { name, phone, email } = req.body;
        if (name) user.name = name;
        if (phone) user.phone = normalizePhoneInput(phone);
        if (email !== undefined) user.email = email;

        await user.save();

        res.json({
            ok: true,
            user: {
                _id: user._id,
                phone: user.phone,
                name: user.name,
                email: user.email,
                emailVerified: user.emailVerified || false,
                phoneVerified: user.phoneVerified || false,
                freeTrialUsed: user.freeTrialUsed,
                createdAt: user.createdAt
            }
        });
    } catch (error) {
        res.status(500).json({ error: 'Failed to update profile' });
    }
});

// Change password
router.post('/change-password', async (req, res) => {
    try {
        const token = req.headers.authorization?.replace('Bearer ', '');
        if (!token) return res.status(401).json({ error: 'No token provided' });

        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        const user = await User.findById(decoded.userId);
        if (!user) return res.status(404).json({ error: 'User not found' });

        const { currentPassword, newPassword } = req.body;
        if (!currentPassword || !newPassword) return res.status(400).json({ error: 'Current password and new password required' });

        const isCurrentPasswordValid = await user.comparePassword(currentPassword);
        if (!isCurrentPasswordValid) return res.status(400).json({ error: 'Current password is incorrect' });

        await user.setPassword(newPassword);
        await user.save();

        // Send password changed confirmation email (async)
        if (user.email) {
            const emailTemplates = require('../lib/emailTemplates');

            emailService.sendEmailAsync({
                to: user.email,
                toName: user.name || user.email,
                subject: 'Password Changed Successfully - Wifi Mtaani',
                htmlContent: emailTemplates.getPasswordChangedTemplate(user.name || 'User'),
            });
        }

        res.json({ ok: true, message: 'Password changed successfully' });
    } catch (error) {
        res.status(500).json({ error: 'Failed to change password' });
    }
});

// Forgot password - send reset email
const { passwordResetLimiter } = require('../middleware/rateLimiter');
router.post('/forgot-password', passwordResetLimiter, async (req, res) => {
    try {
        const { email, phone } = req.body;

        // Allow reset by email or phone
        let user;
        if (email) {
            user = await User.findOne({ email: email.toLowerCase().trim() });
        } else if (phone) {
            const normalizedPhone = normalizePhoneInput(phone);
            user = await User.findOne({ phone: normalizedPhone });
        } else {
            return res.status(400).json({ error: 'Email or phone number is required' });
        }

        // Don't reveal if user exists (security best practice)
        // Always return success message to prevent user enumeration
        if (!user) {
            await LogModel.create({
                level: 'warn',
                source: 'auth',
                message: 'password-reset-requested-for-non-existent-user',
                metadata: { email, phone, ip: req.ip },
            });
            return res.json({
                ok: true,
                message: 'If an account with that email/phone exists, a password reset link has been sent.',
            });
        }

        // Check if user has email (required for password reset)
        if (!user.email) {
            return res.status(400).json({
                error: 'Email address is required for password reset. Please contact support.',
            });
        }

        // Generate reset token
        const resetToken = user.generatePasswordResetToken();
        await user.save();

        // Send reset email
        const emailTemplates = require('../lib/emailTemplates');
        const config = emailService.getEmailConfig();

        const resetLink = `${config.frontendUrl}/auth/reset-password?token=${resetToken}`;

        try {
            await emailService.sendEmail({
                to: user.email,
                toName: user.name || user.email,
                subject: 'Reset Your Password - Wifi Mtaani',
                htmlContent: emailTemplates.getPasswordResetTemplate(
                    user.name || 'User',
                    resetLink,
                    120 // 2 hours in minutes
                ),
            });

            await LogModel.create({
                level: 'info',
                source: 'auth',
                message: 'password-reset-email-sent',
                metadata: { userId: user._id, email: user.email },
            });

            res.json({
                ok: true,
                message: 'If an account with that email/phone exists, a password reset link has been sent.',
            });
        } catch (emailError) {
            logger.error('Failed to send password reset email', {
                userId: user._id,
                email: user.email,
                error: emailError.message,
            });

            // Clear the token if email failed
            user.clearPasswordResetToken();
            await user.save();

            return res.status(500).json({
                error: 'Failed to send password reset email. Please try again later or contact support.',
            });
        }
    } catch (error) {
        logger.error('Forgot password error', { error: error.message, stack: error.stack });
        res.status(500).json({ error: 'An error occurred. Please try again later.' });
    }
});

// Reset password - validate token and update password
router.post('/reset-password', passwordResetLimiter, async (req, res) => {
    try {
        const { token, newPassword } = req.body;

        if (!token || !newPassword) {
            return res.status(400).json({ error: 'Token and new password are required' });
        }

        if (newPassword.length < 6) {
            return res.status(400).json({ error: 'Password must be at least 6 characters' });
        }

        // Find user with matching reset token
        const users = await User.find({
            passwordResetExpires: { $gt: Date.now() },
        });

        let user = null;
        for (const u of users) {
            const isValid = await u.verifyPasswordResetToken(token);
            if (isValid) {
                user = u;
                break;
            }
        }

        if (!user) {
            return res.status(400).json({
                error: 'Invalid or expired reset token. Please request a new password reset.',
            });
        }

        // Update password
        await user.setPassword(newPassword);
        user.clearPasswordResetToken();
        await user.save();

        // Send confirmation email
        if (user.email) {
            const emailTemplates = require('../lib/emailTemplates');

            emailService.sendEmailAsync({
                to: user.email,
                toName: user.name || user.email,
                subject: 'Password Changed Successfully - Wifi Mtaani',
                htmlContent: emailTemplates.getPasswordChangedTemplate(user.name || 'User'),
            });
        }

        await LogModel.create({
            level: 'info',
            source: 'auth',
            message: 'password-reset-completed',
            metadata: { userId: user._id, email: user.email },
        });

        res.json({
            ok: true,
            message: 'Password has been reset successfully. You can now log in with your new password.',
        });
    } catch (error) {
        logger.error('Reset password error', { error: error.message, stack: error.stack });
        res.status(500).json({ error: 'An error occurred. Please try again later.' });
    }
});

// Verify email address
router.post('/verify-email', async (req, res) => {
    try {
        const { token } = req.body;

        if (!token) {
            return res.status(400).json({ error: 'Verification token is required' });
        }

        // Find user with matching verification token
        const users = await User.find({
            emailVerificationExpires: { $gt: Date.now() },
            emailVerified: false
        });

        let user = null;
        for (const u of users) {
            const isValid = await u.verifyEmailVerificationToken(token);
            if (isValid) {
                user = u;
                break;
            }
        }

        if (!user) {
            return res.status(400).json({
                error: 'Invalid or expired verification token. Please request a new verification email.',
            });
        }

        // Mark email as verified
        user.markEmailAsVerified();
        await user.save();

        // Send welcome email after verification
        if (user.email) {
            try {
                const emailTemplates = require('../lib/emailTemplates');
                const config = emailService.getEmailConfig();
                const loginLink = `${config.frontendUrl}/auth/login`;

                emailService.sendEmailAsync({
                    to: user.email,
                    toName: user.name || user.email,
                    subject: 'Welcome to Wifi Mtaani! ðŸŽ‰',
                    htmlContent: emailTemplates.getWelcomeTemplate(user.name || 'User', loginLink),
                }).catch(err => {
                    logger.error('Failed to send welcome email after verification', { error: err.message, userId: user._id });
                });
            } catch (emailError) {
                logger.error('Error sending welcome email after verification', { error: emailError.message, userId: user._id });
            }
        }

        await LogModel.create({
            level: 'info',
            source: 'auth',
            message: 'email-verified',
            metadata: { userId: user._id, email: user.email },
        });

        res.json({
            ok: true,
            message: 'Email verified successfully!',
            user: {
                _id: user._id,
                phone: user.phone,
                name: user.name,
                email: user.email,
                emailVerified: user.emailVerified,
                freeTrialUsed: user.freeTrialUsed,
                createdAt: user.createdAt
            }
        });
    } catch (error) {
        logger.error('Verify email error', { error: error.message, stack: error.stack });
        res.status(500).json({ error: 'An error occurred. Please try again later.' });
    }
});

// Resend email verification
router.post('/resend-verification', async (req, res) => {
    try {
        const { email, phone } = req.body;

        // Allow resend by email or phone
        let user;
        if (email) {
            user = await User.findOne({ email: email.toLowerCase().trim() });
        } else if (phone) {
            const normalizedPhone = normalizePhoneInput(phone);
            user = await User.findOne({ phone: normalizedPhone });
        } else {
            return res.status(400).json({ error: 'Email or phone number is required' });
        }

        // Don't reveal if user exists (security best practice)
        if (!user) {
            return res.json({
                ok: true,
                message: 'If an account with that email/phone exists and is unverified, a verification email has been sent.',
            });
        }

        // Check if email is already verified
        if (user.emailVerified) {
            return res.json({
                ok: true,
                message: 'Email is already verified.',
            });
        }

        // Check if user has an email
        if (!user.email) {
            return res.status(400).json({
                error: 'No email address associated with this account.',
            });
        }

        // Generate new verification token
        const verificationToken = user.generateEmailVerificationToken();
        await user.save();

        // Send verification email
        const emailTemplates = require('../lib/emailTemplates');
        const config = emailService.getEmailConfig();
        const verificationLink = `${config.frontendUrl}/auth/verify-email?token=${verificationToken}`;

        try {
            await emailService.sendEmail({
                to: user.email,
                toName: user.name || user.email,
                subject: 'Verify Your Email Address - Wifi Mtaani',
                htmlContent: emailTemplates.getEmailVerificationTemplate(user.name || 'User', verificationLink, 24),
            });

            await LogModel.create({
                level: 'info',
                source: 'auth',
                message: 'verification-email-resent',
                metadata: { userId: user._id, email: user.email },
            });

            res.json({
                ok: true,
                message: 'If an account with that email/phone exists and is unverified, a verification email has been sent.',
            });
        } catch (emailError) {
            logger.error('Failed to send verification email', {
                userId: user._id,
                email: user.email,
                error: emailError.message,
            });

            // Clear the token if email failed
            user.clearEmailVerificationToken();
            await user.save();

            return res.status(500).json({
                error: 'Failed to send verification email. Please try again later or contact support.',
            });
        }
    } catch (error) {
        logger.error('Resend verification error', { error: error.message, stack: error.stack });
        res.status(500).json({ error: 'An error occurred. Please try again later.' });
    }
});

module.exports = router;
